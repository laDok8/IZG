<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Izg project: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Izg project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000019"></a>Global <a class="el" href="group__program__tasks.html#gafe72b55028369d1e9e9f8d087c76af09">GPU::attachShaders</a>  (ProgramID prg, VertexShader vs, FragmentShader fs)</dt>
<dd>Tato funkce by měla připojít k vybranému shader programu vertex a fragment shader.  </dd>
<dt><a class="anchor" id="_todo000014"></a>Global <a class="el" href="group__vertexpuller__tasks.html#gac7f9799e1a6a3b1cafb5f4c4c5e9555d">GPU::bindVertexPuller</a>  (VertexPullerID vao)</dt>
<dd>Tato funkce aktivuje nastavení vertex pulleru.<br />
 Pokud je daný vertex puller aktivován, atributy z bufferů jsou vybírány na základě jeho nastavení.<br />
  </dd>
<dt><a class="anchor" id="_todo000035"></a>Global <a class="el" href="group__draw__tasks.html#ga012ff10197fb3e5051b854a0028db31d">GPU::clear</a>  (float r, float g, float b, float a)</dt>
<dd>Tato funkce by měla vyčistit framebuffer.<br />
 Barevný buffer vyčistí na barvu podle parametrů r g b a (0 - nulová intenzita, 1 a větší - maximální intenzita).<br />
 (0,0,0) - černá barva, (1,1,1) - bílá barva.<br />
 Hloubkový buffer nastaví na takovou hodnotu, která umožní rasterizaci trojúhelníka, který leží v rámci pohledového tělesa.<br />
 Hloubka by měla být tedy větší než maximální hloubka v NDC (normalized device coordinates).<br />
  </dd>
<dt><a class="anchor" id="_todo000003"></a>Global <a class="el" href="group__buffer__tasks.html#ga309724692e0d90a686642379f12d8d44">GPU::createBuffer</a>  (uint64_t size)</dt>
<dd>Tato funkce by měla na grafické kartě vytvořit buffer dat.<br />
 Velikost bufferu je v parameteru size (v bajtech).<br />
 Funkce by měla vrátit unikátní identifikátor identifikátor bufferu.<br />
 Na grafické kartě by mělo být možné alkovat libovolné množství bufferů o libovolné velikosti.<br />
  </dd>
<dt><a class="anchor" id="_todo000028"></a>Global <a class="el" href="group__framebuffer__tasks.html#gab041c171fc07011d13ec608fc94a1d1c">GPU::createFramebuffer</a>  (uint32_t width, uint32_t height)</dt>
<dd>Tato funkce by měla alokovat framebuffer od daném rozlišení.<br />
 Framebuffer se skládá z barevného a hloukového bufferu.<br />
 Buffery obsahují width x height pixelů.<br />
 Barevný pixel je složen z 4 x uint8_t hodnot - to reprezentuje RGBA barvu.<br />
 Hloubkový pixel obsahuje 1 x float - to reprezentuje hloubku.<br />
 Nultý pixel framebufferu je vlevo dole.<br />
  </dd>
<dt><a class="anchor" id="_todo000017"></a>Global <a class="el" href="group__program__tasks.html#gae1368a616ba5be607b9cf4dd1e60dfe0">GPU::createProgram</a>  ()</dt>
<dd>Tato funkce by měla vytvořit nový shader program.<br />
 Funkce vrací unikátní identifikátor nového proramu.<br />
 Program je seznam nastavení, které obsahuje: ukazatel na vertex a fragment shader.<br />
 Dále obsahuje uniformní proměnné a typ výstupních vertex attributů z vertex shaderu, které jsou použity pro interpolaci do fragment atributů.<br />
  </dd>
<dt><a class="anchor" id="_todo000008"></a>Global <a class="el" href="group__vertexpuller__tasks.html#gaabe965c10fea7cd8f8af3aa528915c92">GPU::createVertexPuller</a>  ()</dt>
<dd>Tato funkce vytvoří novou práznou tabulku s nastavením pro vertex puller.<br />
 Funkce by měla vrátit identifikátor nové tabulky. Prázdná tabulka s nastavením neobsahuje indexování a všechny čtecí hlavy jsou vypnuté.  </dd>
<dt><a class="anchor" id="_todo000004"></a>Global <a class="el" href="group__buffer__tasks.html#ga05fb19b7c8b51a92162517aa7f25a166">GPU::deleteBuffer</a>  (BufferID buffer)</dt>
<dd>Tato funkce uvolní buffer na grafické kartě. Buffer pro smazání je vybrán identifikátorem v parameteru "buffer". Po uvolnění bufferu je identifikátor volný a může být znovu použit při vytvoření nového bufferu.  </dd>
<dt><a class="anchor" id="_todo000029"></a>Global <a class="el" href="group__framebuffer__tasks.html#gaaaa9fbf5f3c28f27f092c2c6883d6e60">GPU::deleteFramebuffer</a>  ()</dt>
<dd>tato funkce by měla dealokovat framebuffer.  </dd>
<dt><a class="anchor" id="_todo000018"></a>Global <a class="el" href="group__program__tasks.html#ga3f8363f9c27c3f900f258e6acee52683">GPU::deleteProgram</a>  (ProgramID prg)</dt>
<dd>Tato funkce by měla smazat vybraný shader program.<br />
 Funkce smaže nastavení shader programu.<br />
 Identifikátor programu se stane volným a může být znovu využit.<br />
  </dd>
<dt><a class="anchor" id="_todo000009"></a>Global <a class="el" href="group__vertexpuller__tasks.html#gadf91a9fec77d8d23f093458b36a733fc">GPU::deleteVertexPuller</a>  (VertexPullerID vao)</dt>
<dd>Tato funkce by měla odstranit tabulku s nastavení pro vertex puller.<br />
 Parameter "vao" obsahuje identifikátor tabulky s nastavením.<br />
 Po uvolnění nastavení je identifiktátor volný a může být znovu použit.<br />
  </dd>
<dt><a class="anchor" id="_todo000013"></a>Global <a class="el" href="group__vertexpuller__tasks.html#gae95cab56d80cb888e71b25965dc868c5">GPU::disableVertexPullerHead</a>  (VertexPullerID vao, uint32_t head)</dt>
<dd>Tato funkce zakáže čtecí hlavu daného vertex pulleru.<br />
 Pokud je čtecí hlava zakázána, hodnoty z bufferu se nebudou kopírovat do atributu vrcholu.<br />
 Parametry "vao" a "head" vybírají vertex puller a čtecí hlavu.<br />
  </dd>
<dt><a class="anchor" id="_todo000036"></a>Global <a class="el" href="group__draw__tasks.html#ga127436afbcbda852746dfb9dae885ecf">GPU::drawTriangles</a>  (uint32_t nofVertices)</dt>
<dd>Tato funkce vykreslí trojúhelníky podle daného nastavení.<br />
 Vrcholy se budou vybírat podle nastavení z aktivního vertex pulleru (pomocí bindVertexPuller).<br />
 Vertex shader a fragment shader se zvolí podle aktivního shader programu (pomocí useProgram).<br />
 Parametr "nofVertices" obsahuje počet vrcholů, který by se měl vykreslit (3 pro jeden trojúhelník).<br />
  </dd>
<dt><a class="anchor" id="_todo000012"></a>Global <a class="el" href="group__vertexpuller__tasks.html#ga61384d99754bda4d91790c49b1639b30">GPU::enableVertexPullerHead</a>  (VertexPullerID vao, uint32_t head)</dt>
<dd>Tato funkce povolí čtecí hlavu daného vertex pulleru.<br />
 Pokud je čtecí hlava povolena, hodnoty z bufferu se budou kopírovat do atributu vrcholů vertex shaderu.<br />
 Parametr "vao" volí tabulku s nastavením vertex pulleru (vybírá vertex puller).<br />
 Parametr "head" volí čtecí hlavu.<br />
  </dd>
<dt><a class="anchor" id="_todo000006"></a>Global <a class="el" href="group__buffer__tasks.html#ga7b89dbe4afbfec3725c64000b37445af">GPU::getBufferData</a>  (BufferID buffer, uint64_t offset, uint64_t size, void *data)</dt>
<dd>Tato funkce vykopíruje data z "gpu" na cpu. Data by měla být vykopírována z bufferu vybraného parametrem "buffer".<br />
 Parametr size určuje kolik dat (v bajtech) se překopíruje.<br />
 Parametr offset určuje místo v bufferu (posun v bajtech) odkud se začne kopírovat.<br />
 Parametr data obsahuje ukazatel, kam se data nakopírují.<br />
  </dd>
<dt><a class="anchor" id="_todo000031"></a>Global <a class="el" href="group__framebuffer__tasks.html#ga67504b8136ef6283ad6efbb5323a0ef8">GPU::getFramebufferColor</a>  ()</dt>
<dd>Tato funkce by měla vrátit ukazatel na začátek barevného bufferu.<br />
  </dd>
<dt><a class="anchor" id="_todo000032"></a>Global <a class="el" href="group__framebuffer__tasks.html#gab755d51ff9686df1fb9b2892b9861c1d">GPU::getFramebufferDepth</a>  ()</dt>
<dd>tato funkce by mla vrátit ukazatel na začátek hloubkového bufferu.<br />
  </dd>
<dt><a class="anchor" id="_todo000034"></a>Global <a class="el" href="group__framebuffer__tasks.html#gaa115f7153407b8020fd153b71abccf0e">GPU::getFramebufferHeight</a>  ()</dt>
<dd>Tato funkce by měla vrátit výšku framebufferu.  </dd>
<dt><a class="anchor" id="_todo000033"></a>Global <a class="el" href="group__framebuffer__tasks.html#ga467b565d440e5742b7ebc104a2d70ce3">GPU::getFramebufferWidth</a>  ()</dt>
<dd>Tato funkce by měla vrátit šířku framebufferu.  </dd>
<dt><a class="anchor" id="_todo000001"></a>Global <a class="el" href="group__gpu__init.html#ga2ca7973e32f63ba3472166a007419a75">GPU::GPU</a>  ()</dt>
<dd>Zde můžete alokovat/inicializovat potřebné proměnné grafické karty  </dd>
<dt><a class="anchor" id="_todo000007"></a>Global <a class="el" href="group__buffer__tasks.html#gae725a1955d617a7e655ab751c6e05e97">GPU::isBuffer</a>  (BufferID buffer)</dt>
<dd>Tato funkce by měla vrátit true pokud buffer je identifikátor existující bufferu.<br />
 Tato funkce by měla vrátit false, pokud buffer není identifikátor existujícího bufferu. (nebo bufferu, který byl smazán).<br />
 Pro emptyId vrací false.<br />
  </dd>
<dt><a class="anchor" id="_todo000022"></a>Global <a class="el" href="group__program__tasks.html#ga481c0eb5be3150af401a58fa167506e0">GPU::isProgram</a>  (ProgramID prg)</dt>
<dd>tato funkce by měla zjistit, zda daný program existuje.<br />
 Funkce vráti true, pokud program existuje.<br />
  </dd>
<dt><a class="anchor" id="_todo000016"></a>Global <a class="el" href="group__vertexpuller__tasks.html#ga09408b5ca4250292217f3330ae674319">GPU::isVertexPuller</a>  (VertexPullerID vao)</dt>
<dd>Tato funkce otestuje, zda daný vertex puller existuje. Pokud ano, funkce vrací true.  </dd>
<dt><a class="anchor" id="_todo000023"></a>Global <a class="el" href="group__program__tasks.html#gaa9e9717db5520e6c34a1b380d6321758">GPU::programUniform1f</a>  (ProgramID prg, uint32_t uniformId, float const &amp;d)</dt>
<dd>tato funkce by měla nastavit uniformní proměnnou shader programu.<br />
 Parametr "prg" vybírá shader program.<br />
 Parametr "uniformId" vybírá uniformní proměnnou. Maximální počet uniformních proměnných je uložen v programné <a class="el" href="fwd_8hpp.html#abb316cce98ea6938a7112c5f932d673f">maxUniforms</a>.<br />
 Parametr "d" obsahuje data (1 float).<br />
  </dd>
<dt><a class="anchor" id="_todo000024"></a>Global <a class="el" href="group__program__tasks.html#gac34e13783980686c497adda156923b1d">GPU::programUniform2f</a>  (ProgramID prg, uint32_t uniformId, glm::vec2 const &amp;d)</dt>
<dd>tato funkce dělá obdobnou věc jako funkce programUniform1f.<br />
 Místo 1 floatu nahrává 2 floaty.  </dd>
<dt><a class="anchor" id="_todo000025"></a>Global <a class="el" href="group__program__tasks.html#ga06b1aca1375a9cfff13d3b66defe485f">GPU::programUniform3f</a>  (ProgramID prg, uint32_t uniformId, glm::vec3 const &amp;d)</dt>
<dd>tato funkce dělá obdobnou věc jako funkce programUniform1f.<br />
 Místo 1 floatu nahrává 3 floaty.  </dd>
<dt><a class="anchor" id="_todo000026"></a>Global <a class="el" href="group__program__tasks.html#gad703e87e1652a78261739c6b5108c852">GPU::programUniform4f</a>  (ProgramID prg, uint32_t uniformId, glm::vec4 const &amp;d)</dt>
<dd>tato funkce dělá obdobnou věc jako funkce programUniform1f.<br />
 Místo 1 floatu nahrává 4 floaty.  </dd>
<dt><a class="anchor" id="_todo000027"></a>Global <a class="el" href="group__program__tasks.html#gac3b490a674226c0510ac3c0b784010fa">GPU::programUniformMatrix4f</a>  (ProgramID prg, uint32_t uniformId, glm::mat4 const &amp;d)</dt>
<dd>tato funkce dělá obdobnou věc jako funkce programUniform1f.<br />
 Místo 1 floatu nahrává matici 4x4 (16 floatů).  </dd>
<dt><a class="anchor" id="_todo000030"></a>Global <a class="el" href="group__framebuffer__tasks.html#ga6391eaf70194c39bf523ddc875ca176d">GPU::resizeFramebuffer</a>  (uint32_t width, uint32_t height)</dt>
<dd>Tato funkce by měla změnit velikost framebuffer.  </dd>
<dt><a class="anchor" id="_todo000005"></a>Global <a class="el" href="group__buffer__tasks.html#ga97e1e76065fd913d6624b4c03164dcec">GPU::setBufferData</a>  (BufferID buffer, uint64_t offset, uint64_t size, void const *data)</dt>
<dd>Tato funkce nakopíruje data z cpu na "gpu".<br />
 Data by měla být nakopírována do bufferu vybraného parametrem "buffer".<br />
 Parametr size určuje, kolik dat (v bajtech) se překopíruje.<br />
 Parametr offset určuje místo v bufferu (posun v bajtech) kam se data nakopírují.<br />
 Parametr data obsahuje ukazatel na data na cpu pro kopírování.<br />
  </dd>
<dt><a class="anchor" id="_todo000010"></a>Global <a class="el" href="group__vertexpuller__tasks.html#gae9ffbcfa3b43ac9b3ea53e5bc44f83cc">GPU::setVertexPullerHead</a>  (VertexPullerID vao, uint32_t head, AttributeType type, uint64_t stride, uint64_t offset, BufferID buffer)</dt>
<dd>Tato funkce nastaví jednu čtecí hlavu vertex pulleru.<br />
 Parametr "vao" vybírá tabulku s nastavením.<br />
 Parametr "head" vybírá čtecí hlavu vybraného vertex pulleru.<br />
 Parametr "type" nastaví typ atributu, který čtecí hlava čte. Tímto se vybere kolik dat v bajtech se přečte.<br />
 Parametr "stride" nastaví krok čtecí hlavy.<br />
 Parametr "offset" nastaví počáteční pozici čtecí hlavy.<br />
 Parametr "buffer" vybere buffer, ze kterého bude čtecí hlava číst.<br />
  </dd>
<dt><a class="anchor" id="_todo000011"></a>Global <a class="el" href="group__vertexpuller__tasks.html#gae5238dbc60eb2ece94df110945a4f46b">GPU::setVertexPullerIndexing</a>  (VertexPullerID vao, IndexType type, BufferID buffer)</dt>
<dd>Tato funkce nastaví indexování vertex pulleru. Parametr "vao" vybírá tabulku s nastavením.<br />
 Parametr "type" volí typ indexu, který je uložený v bufferu.<br />
 Parametr "buffer" volí buffer, ve kterém jsou uloženy indexy.<br />
  </dd>
<dt><a class="anchor" id="_todo000020"></a>Global <a class="el" href="group__program__tasks.html#gaff499d4f692ea0dd7125bfd324957619">GPU::setVS2FSType</a>  (ProgramID prg, uint32_t attrib, AttributeType type)</dt>
<dd>tato funkce by měla zvolit typ vertex atributu, který je posílán z vertex shaderu do fragment shaderu.<br />
 V průběhu rasterizace vznikají fragment.<br />
 Fragment obsahují fragment atributy.<br />
 Tyto atributy obsahují interpolované hodnoty vertex atributů.<br />
 Tato funkce vybere jakého typu jsou tyto interpolované atributy.<br />
 Bez jakéhokoliv nastavení jsou atributy prázdne <a class="el" href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2aba2b45bdc11e2a4a6e86aab2ac693cbb" title="disabled attribute ">AttributeType::EMPTY</a><br />
  </dd>
<dt><a class="anchor" id="_todo000015"></a>Global <a class="el" href="group__vertexpuller__tasks.html#gafdfb7e3cd24d595af6650b68ba9f6f24">GPU::unbindVertexPuller</a>  ()</dt>
<dd>Tato funkce deaktivuje vertex puller. To většinou znamená, že se vybere neexistující "emptyID" vertex puller.  </dd>
<dt><a class="anchor" id="_todo000021"></a>Global <a class="el" href="group__program__tasks.html#ga4f2bd468b0ef5fed61ffa34314319a20">GPU::useProgram</a>  (ProgramID prg)</dt>
<dd>tato funkce by měla vybrat aktivní shader program.  </dd>
<dt><a class="anchor" id="_todo000002"></a>Global <a class="el" href="group__gpu__init.html#gac4d153a08d3b9f40e5a8f1634f4a9e78">GPU::~GPU</a>  ()</dt>
<dd>Zde můžete dealokovat/deinicializovat grafickou kartu  </dd>
<dt><a class="anchor" id="_todo000037"></a>Module <a class="el" href="group__gpu__init.html">gpu_init</a>  </dt>
<dd>zde si můžete vytvořit proměnné grafické karty (buffery, programy, ...)  </dd>
<dt><a class="anchor" id="_todo000039"></a>Global <a class="el" href="group__shader__side.html#gacad0f238507689fa275995e3aa67ce22">phong_FS</a>  (<a class="el" href="structOutFragment.html" title="This struct represents output fragment. ">OutFragment</a> &amp;outFragment, <a class="el" href="structInFragment.html" title="This struct represents input fragment. ">InFragment</a> const &amp;inFragment, <a class="el" href="structUniforms.html" title="This struct represents shader program uniform variables. ">Uniforms</a> const &amp;uniforms)</dt>
<dd>Naimplementujte fragment shader, který počítá phongův osvětlovací model s phongovým stínováním.<br />
 <b>Vstup:</b><br />
 Vstupní fragment by měl v nultém fragment atributu obsahovat interpolovanou pozici ve world-space a v prvním fragment atributu obsahovat interpolovanou normálu ve world-space.<br />
 <b>Výstup:</b><br />
 Barvu zapište do proměnné gl_FragColor ve výstupní struktuře.<br />
 <b>Uniformy:</b><br />
 Pozici kamery přečtěte z uniformní 3 a pozici světla přečtěte z uniformní 2. <br />
 <br />
 Dejte si pozor na velikost normálového vektoru, při lineární interpolaci v rasterizaci může dojít ke zkrácení. Zapište barvu do proměnné gl_FragColor ve výstupní struktuře. Shininess faktor nastavte na 40.f <br />
 <br />
 Difuzní barva materiálu (textura) by měla být procedurálně generována. Textura je složena zde dvou částí: sinusové pruhy a bílý sněhový poprašek. Textura je zkombinována z těchto dvou částí podle sklonu normály. V případě, že normála směřuje kolmo vzhůru je textura čistě bílá. V případě, že normála směřuje vodorovně nebo dolů je textura složena ze sinusových pruhů. Bílá textura a textura sinusových pruhů je lineráně míchana pomocí interpolačního parameteru t. Interpolační parameter t spočtěte z y komponenty normály pomocí t = y*y (samozřejmě s ohledem na negativní čísla). </dd>
<dt><a class="anchor" id="_todo000038"></a>Global <a class="el" href="group__shader__side.html#ga128e1d2afb1e73269e5a1d4eaf4c23cb">phong_VS</a>  (<a class="el" href="structOutVertex.html" title="This struct represents output vertex of vertex shader. ">OutVertex</a> &amp;outVertex, <a class="el" href="structInVertex.html" title="This struct represents input vertex of vertex shader. ">InVertex</a> const &amp;inVertex, <a class="el" href="structUniforms.html" title="This struct represents shader program uniform variables. ">Uniforms</a> const &amp;uniforms)</dt>
<dd>Naimplementujte vertex shader, který transformuje vstupní vrcholy do clip-space.<br />
 <b>Vstupy:</b><br />
 Vstupní vrchol by měl v nultém atributu obsahovat pozici vrcholu ve world-space (vec3) a v prvním atributu obsahovat normálu vrcholu ve world-space (vec3).<br />
 <b>Výstupy:</b><br />
 Výstupní vrchol by měl v nultém atributu obsahovat pozici vrcholu (vec3) ve world-space a v prvním atributu obsahovat normálu vrcholu ve world-space (vec3). Výstupní vrchol obsahuje pozici a normálu vrcholu proto, že chceme počítat osvětlení ve world-space ve fragment shaderu.<br />
 <b>Uniformy:</b><br />
 Vertex shader by měl pro transformaci využít uniformní proměnné obsahující view a projekční matici. View matici čtěte z nulté uniformní proměnné a projekční matici čtěte z první uniformní proměnné. <br />
 Využijte vektorové a maticové funkce. Nepředávajte si data do shaderu pomocí globálních proměnných. Vrchol v clip-space by měl být zapsán do proměnné gl_Position ve výstupní struktuře.  </dd>
<dt><a class="anchor" id="_todo000041"></a>Global <a class="el" href="group__cpu__side.html#ga100e32901442800e1c155b5ce089f7c5">PhongMethod::onDraw</a>  (glm::mat4 const &amp;proj, glm::mat4 const &amp;view, glm::vec3 const &amp;light, glm::vec3 const &amp;camera) override</dt>
<dd>Doprogramujte kreslící funkci. Zde byste měli aktivovat shader program, aktivovat vertex puller, nahrát data do uniformních proměnných a vykreslit trojúhelníky pomocí funkce <a class="el" href="group__draw__tasks.html#ga127436afbcbda852746dfb9dae885ecf">GPU::drawTriangles</a>. Data pro uniformní proměnné naleznete v parametrech této funkce. <b>Seznam funkcí, které jistě využijete:</b><ul>
<li>gpu.bindVertexPuller()</li>
<li>gpu.useProgram()</li>
<li>gpu.programUniformMatrix4f()</li>
<li>gpu.programUniform3f ()</li>
<li>gpu.drawTriangles()</li>
<li>gpu.unbindVertexPuller()  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000040"></a>Global <a class="el" href="group__cpu__side.html#ga609f942b12f18a74313937d4aa071c0b">PhongMethod::PhongMethod</a>  ()</dt>
<dd>Doprogramujte inicializační funkci. Zde byste měli vytvořit buffery na <a class="el" href="classGPU.html" title="This class represent software GPU. ">GPU</a>, nahrát data do bufferů, vytvořit vertex puller a správně jej nakonfigurovat, vytvořit program, připojit k němu shadery a nastavit atributy, které se posílají mezi vs a fs. Do bufferů nahrajte vrcholy králička (pozice, normály) a indexy na vrcholy ze souboru <a class="el" href="bunny_8hpp.html">bunny.hpp</a>. Shader program by měl odkazovat na funkce/shadery phong_VS a phong_FS. V konfiguraci vertex pulleru nastavte dvě čtecí hlavy. Jednu pro pozice vrcholů a druhou pro normály vrcholů. Nultý vertex/fragment atribut by měl obsahovat pozici vertexu. První vertex/fragment atribut by měl obsahovat normálu vertexu. Nastavte, které atributy (jaký typ) se posílají z vertex shaderu do fragment shaderu. <b>Seznam funkcí, které jistě využijete:</b><ul>
<li>gpu.createBuffer()</li>
<li>gpu.setBufferData()</li>
<li>gpu.createVertexPuller()</li>
<li>gpu.setVertexPullerIndexing()</li>
<li>gpu.setVertexPullerHead()</li>
<li>gpu.enableVertexPullerHead()</li>
<li>gpu.createProgram()</li>
<li>gpu.attachShaders()</li>
<li>gpu.setVS2FSType()  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000042"></a>Global <a class="el" href="group__cpu__side.html#ga64fbf177f01aca9027d510611a2dad73">PhongMethod::~PhongMethod</a>  ()</dt>
<dd>Zde uvolněte alokované zdroje <b>Seznam funkcí</b><ul>
<li>gpu.deleteProgram()</li>
<li>gpu.deleteVertexPuller()</li>
<li>gpu.deleteBuffer() </li>
</ul>
</dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 23 2020 14:04:20 for Izg project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
