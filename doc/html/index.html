<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Izg project: Izg project.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Izg project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Izg project. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#zadani">Zadání projektu do předmětu IZG.</a><ul><li class="level2"><a href="#Overview">Vytváření objektů na grafické kartě (1a. úkol)</a></li>
<li class="level2"><a href="#Draw">Kreslení (1b. úkol)</a><ul><li class="level3"><a href="#Pipeline">Pipeline</a></li>
<li class="level3"><a href="#VertexPuller">Vertex Puller</a></li>
<li class="level3"><a href="#VertexProcessor">Vertex Processor</a></li>
<li class="level3"><a href="#PrimitiveAssembly">Primitive Assembly</a></li>
<li class="level3"><a href="#Clipping">Clipping</a></li>
<li class="level3"><a href="#PerspectiveDivision">Perspektivní dělení</a></li>
<li class="level3"><a href="#ViewPortTransformation">Viewport transformace</a></li>
<li class="level3"><a href="#Rasterization">Rasterizace</a></li>
<li class="level3"><a href="#FragmentProcessor">Fragment processor</a></li>
<li class="level3"><a href="#PFO">Per-fragment operace</a></li>
</ul>
</li>
<li class="level2"><a href="#PhongMethod">Implementace vykreslovací metody PhongMethod (úkol 2.)</a></li>
<li class="level2"><a href="#terminologie">Terminologie</a></li>
</ul>
</li>
<li class="level1"><a href="#rozdeleni">Rozdělení</a></li>
<li class="level1"><a href="#sestaveni">Sestavení</a></li>
<li class="level1"><a href="#spousteni">Spouštění</a></li>
<li class="level1"><a href="#ovladani">Ovládání</a></li>
<li class="level1"><a href="#odevzdavani">Odevzdávání</a></li>
<li class="level1"><a href="#hodnoceni">Hodnocení</a></li>
<li class="level1"><a href="#soutez">Soutěž</a></li>
<li class="level1"><a href="#zaver">Závěrem</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="zadani"></a>
Zadání projektu do předmětu IZG.</h1>
<div class="image">
<img src="output.png" alt="output.png"/>
<div class="caption">
Výstup projektu</div></div>
<p> Vašim úkolem je naimplementovat jednoduchou grafickou kartu (gpu). Pomocí gpu vizualizovat model králička s phongovým osvělovacím modelem a phongovým stínováním s procedurální texturou. Cílem projektu je naučit vás jak fungují dnešní grafické karty a jak tyto karty ovládat pomocí API (které je blízké k OpenGL). Každý úkol má přiřazen akceptační test, takže si můžete snadno ověřit funkčnosti vaší implementace. Dále doporučuji prozkoumání, jak je tento projekt udělán. Můžete se naučit jak udělat CMake, jak udělat unit testy, jak psát doxygen. Klidně se mě můžete na tyto věci zeptat. <br />
 Úkol je složen ze dvou částí: </p><ol>
<li>
implementace <a class="el" href="classGPU.html" title="This class represent software GPU. ">GPU</a> </li>
<li>
využití <a class="el" href="classGPU.html" title="This class represent software GPU. ">GPU</a> pro vykreslení otexturovaného králíčka vrámci <a class="el" href="classPhongMethod.html" title="This class holds all variables of phong method. ">PhongMethod</a> vykreslovací metody. </li>
</ol>
<div class="image">
<object type="image/svg+xml" data="tasks.svg" width="800">tasks.svg</object>
<div class="caption">
Hlavní rozdělení úkolů</div></div>
<p> <br />
 Všechny úkoly naleznete zde: <a href="modules.html">kategorie úkolů</a> nebo v kompletním výpisu <a class="el" href="todo.html">todo.html</a>.</p>
<h2><a class="anchor" id="Overview"></a>
Vytváření objektů na grafické kartě (1a. úkol)</h2>
<p>V tomto úkolu je potřeba implementovat obslužné funkcé pro objekty na grafické kartě. Stači editovat soubory <a class="el" href="gpu_8hpp.html">gpu.hpp</a> a <a class="el" href="gpu_8cpp.html">gpu.cpp</a>. <br />
 <br />
 Grafická karta je složena z paměti a výpočetního / vykreslovacího řetězce (pipeline). </p><div class="image">
<object type="image/svg+xml" data="gpu_memory_pipeline.svg" width="600">gpu_memory_pipeline.svg</object>
<div class="caption">
základní schéma grafické karty.</div></div>
<p> V paměti je uloženo několik informací. Jsou to: </p><ul>
<li>
Buffery </li>
<li>
Tabulky s nastavením vertex pullerů </li>
<li>
Shader programy a jejich nastavení včetně uniformích proměnných </li>
<li>
Framebuffer </li>
</ul>
<div class="image">
<object type="image/svg+xml" data="gpu_memory.svg" width="400">gpu_memory.svg</object>
<div class="caption">
Objekty uložené v paměti</div></div>
<p> Ke každému typu objektu se vážou obslužné funkce. Tyto funkce můžou vytvořit nové objekty. Náhrát do nich data. Vyčíst z nich data nebo je smazat. Každý objekt je identifikován pomocí celočíselného identifikátoru <a class="el" href="fwd_8hpp.html#a5114031b77b80ad895eff688720b7f93">BufferID</a>, <a class="el" href="fwd_8hpp.html#a46ffd067c21ab50f5f1fcfed5d8bfc15">ProgramID</a>, <a class="el" href="fwd_8hpp.html#af6f78f73099477c9ce5537d657597486">VertexPullerID</a>. Objekt který neexistuje má identifikátor <a class="el" href="fwd_8hpp.html#a85f029d54035997f9d5f499008d5f623">emptyID</a>. Situace je znázorněna na následujícím obrázku:</p>
<div class="image">
<object type="image/svg+xml" data="gpu_id.svg" width="800">gpu_id.svg</object>
<div class="caption">
Objekty na GPU jsou identifikovány pomocí celočíselných identifikátorů. Při vytvoření objektu na grafické kartě je na cpu stranu vrácen identifikátor, pomocí kterého je možné s objektem operovat.</div></div>
<p>K těmto 4 objektům se vážou 4 podčásti úkolu: </p><ul>
<li>
<a class="el" href="group__buffer__tasks.html">Implementace obslužných funkcí pro buffery</a> </li>
<li>
<a class="el" href="group__vertexpuller__tasks.html">Implementace obslužných funkcí pro vertex pullery</a> </li>
<li>
<a class="el" href="group__program__tasks.html">Implementace obslužných funkcí pro shader programy</a> </li>
<li>
<a class="el" href="group__framebuffer__tasks.html">Implementace obslužných funkcí pro framebuffer</a> </li>
</ul>
<p>Po implementaci těchto 4 úkolu by mělo být možné na grafické kartě vytvářet objekty a upravovat je. Pro implementaci těchto úkolů můžete vytvářet proměnné uvnitř třídy <a class="el" href="classGPU.html" title="This class represent software GPU. ">GPU</a> a inicializovat je v konstruktoru a deinicializovat je v destruktoru této třídy: </p><ul>
<li>
<a class="el" href="group__gpu__init.html">proměnné, inicializace, deinicializace</a>. </li>
</ul>
<p>Po implementaci obslužných funkcí pro objekty můžete implementovat vykreslovací funkce - funkcionalitu vykreslovacího řetězce. </p>
<h2><a class="anchor" id="Draw"></a>
Kreslení (1b. úkol)</h2>
<p>Další úkoly se týkají kreslení. Stejně jako předchozí úkol, je potřeba editovat akorát soubory <a class="el" href="gpu_8cpp.html">gpu.cpp</a> a <a class="el" href="gpu_8hpp.html">gpu.hpp</a>. Je nutné naprogramovat 2 kreslící funkce. První pouze vymaže framebuffer <a class="el" href="group__draw__tasks.html#ga012ff10197fb3e5051b854a0028db31d">GPU::clear</a>, druhá vyrasterizuje seznam trojúhelníků <a class="el" href="group__draw__tasks.html#ga127436afbcbda852746dfb9dae885ecf">GPU::drawTriangles</a>. V této části je popsána teorie kreslení na grafických kartách, kterou budete muset zreplikovat v kódě. </p>
<h3><a class="anchor" id="Pipeline"></a>
Pipeline</h3>
<p>Vykreslovací řetězec je zobrazen na následujícím obrázku: </p><div class="image">
<object type="image/svg+xml" data="rendering_pipeline.svg">rendering_pipeline.svg</object>
<div class="caption">
Simplified rendering pipeline</div></div>
<p>Všechny části tohoto obrázku je potřeba implementovat vrámci kreslící funkce pro kreslení trojúhelníků, jmenovitě: </p><ol>
<li>
Vertex Puller </li>
<li>
Vertex Processor </li>
<li>
Primitive Assembly </li>
<li>
Clipping </li>
<li>
Perspective Division </li>
<li>
Viewport Transformation </li>
<li>
Rasterization </li>
<li>
Fragment Processor </li>
<li>
Per-Fragment Operation (Depth test) </li>
</ol>
<h3><a class="anchor" id="VertexPuller"></a>
Vertex Puller</h3>
<p>Detailnější popis, co dělá vertex puller naleznete v úkolu <a class="el" href="group__vertexpuller__tasks.html">Implementace obslužných funkcí vertex pulleru</a>. Hlavní účel vertex pulleru je sestavení vrcholů pro vertex procesor. Vertex puller je zařízení, které vyčte data z několik bufferů a staví vrchol (struktura několika vertex atributů). Úživatel grafické karty má možnost měnit nastavení vertex pulleru. Může měnit počet vertex atributů v sestavovaném vrcholu. Může měnit buffery, ze kterých jsou jednotlivé vertex atributy čteny, může měnit způsob čtení (offset a stride (krok)). Toto nastavení je uloženo v tabulce (často se ji říká VAO (vertex array object)). Úživatel může na grafické kartě vytvořit několik takovýchto tabulek s nastavením a libovolně mezi nimi přepínat. </p><div class="image">
<object type="image/svg+xml" data="VertexPuller.svg" width="800">VertexPuller.svg</object>
<div class="caption">
Vizualizace funkcionality vertex pulleru. Nastavení vertex pulleru je uloženo na grafické kartě. Uživatel si může vybrat jedno nastavení. Vertex Puller podle daného nastavení sestaví vrchol,. Vertex Puller čte data z bufferů, kterým se říká Vertex Buffer. Případně je čtení řízeno ještě indexy z Index Bufferu.</div></div>
<h3><a class="anchor" id="VertexProcessor"></a>
Vertex Processor</h3>
<p>Úkolem vertex processoru je transformace vrcholů pomocí transformačních matic. Vertex processor vykonává shader (kus programu), kterému se říká vertex shader. Vstupem vertex shaderu je vrchol <a class="el" href="structInVertex.html">InVertex</a>, výstupem je vrchol <a class="el" href="structOutVertex.html">OutVertex</a>. Dalším (konstatním) vstupem vertex shaderu jsou uniformní proměnné <a class="el" href="structUniforms.html">Uniforms</a>, které jsou uložené v rámci shader programu. Pokud se uživatel rozhodne vykreslit 5 trojúhelníků je vertex shader spuštěn <img class="formulaInl" alt="$ 5 \cdot 3 = 15 $" src="form_0.png"/>. Jednotlivé spuštění (invokace) vertex shaderu vyžadují nové vstupní vrcholy a produkují nové výstupní vrcholy. To ve výsledku znamená, že se pro každou invokaci vertex shaderu spustí vertex puller, který sestaví vstupní vrchol. </p><div class="image">
<object type="image/svg+xml" data="vertexShader.svg" width="800">vertexShader.svg</object>
<div class="caption">
Vizualizace vstupů a výstupů vertex procesoru. Ve vertex procesoru běží vertex shader, který obdrží vstupní vrchol, vyprodukuje výstupní vrchol a obdrží vstupní konstanty (uniformní proměnné).</div></div>
<p>Vertex Shader je v tomto projektu reprezentován jako C++ funkce. Tato funkce má pevný typ <a class="el" href="fwd_8hpp.html#af647cdb302d7e978c6a0da41a0a92725">VertexShader</a>. Příklad jak může vypadat takový vertex shader můžete najít třeba tady <a class="el" href="czFlagMethod_8cpp.html#a787e2577e9bc9e3a1d683e567222c827">czFlag_VS</a>.</p>
<h3><a class="anchor" id="PrimitiveAssembly"></a>
Primitive Assembly</h3>
<p>Primitive Assembly je jednotka která sestavuje trojúhelníky (mimo jiné). Trojúhelníku, úsečce, bodu se hromadně říká primitivum. V tomto projektu se používají pouze trojúhelníky. Primitive Assembly jednotka si počká na 3 po sobě jdoucí <a class="el" href="structOutVertex.html">výstupní vrcholy</a> z vertex shaderu a sestaví trojúhelník (struktura která by měla obsahovat 3 výstupní vrcholy). Lze na to také nahlížet tak, že primitiv assembly jednotka dostane příkaz vykreslit třeba 4 trojúhelníky. Jednotka tak spustí vertex shader 12x, který takto spustí 12x vertex puller.</p>
<div class="image">
<object type="image/svg+xml" data="PrimitiveAssembly.svg" width="800">PrimitiveAssembly.svg</object>
<div class="caption">
Vizualizace funkce primitive assembly jednotky. Primitive assembly jednotka sestaví trojúhelník ze 3 po sobě jdoucích výstupních vrcholů z vertex shaderu.</div></div>
<h3><a class="anchor" id="Clipping"></a>
Clipping</h3>
<p>Ořez (clipping) slouží pro odstranění částí trojúhelníků, které leží mimo pohledový jehlan. Nejdůležitější je však ořet near ořezovou rovinou pohledoveho jehlanu. Pokud by se neprovedl ořez pomocí near roviny, pak by se vrcholy nebo i celé trojúhělníky, které leží za středem projekce promítly při perspektivním dělení na průmětnu. Ořez se provádí v clip-space - po pronásobení vrcholů projekční maticí. Pro body, které leží uvnitř pohledového tělesa platí, že jejich souřadnice splňují následující nerovnice: <img class="formulaInl" alt="$ -A_w \leq A_i \leq +A_w $" src="form_1.png"/>, <img class="formulaInl" alt="$i \in \left\{ x,y,z \right\}$" src="form_2.png"/>. Těchto 6 nerovnic reprezentuje jednotlivé svěny pohledového jehlanu. Nerovnice <img class="formulaInl" alt="$ -A_w \leq A_z $" src="form_3.png"/> reprezentuje podmínku pro near ořezovou rovinu. <br />
 Při ořezu trojúhelníku můžou nastat 4 případy, jsou znázorněny na následujícím obrázku:</p>
<div class="image">
<object type="image/svg+xml" data="clip_variants.svg">clip_variants.svg</object>
<div class="caption">
4 varianty ořezu trojúhelníku pomocí near roviny. Počet vrcholů, které leží před ořezovou rovinou určuje typ ořezu. Při ořezu může vzniknout 0 až 2 nové trojúhelníky.</div></div>
<p> Ořez trojúhelníku pomocí near roviny lze zjednodušit na ořez hran trojúhelníku. Bod na hraně (úsečce) trojúhelníku lze vyjádřit jako: <img class="formulaInl" alt="$ \overrightarrow{X(t)} = \overrightarrow{A} + t \cdot (\overrightarrow{B}-\overrightarrow{A}) $" src="form_4.png"/>, <img class="formulaInl" alt="$t \in [0,1] $" src="form_5.png"/>. <img class="formulaInl" alt="$ \overrightarrow{A}, \overrightarrow{B} $" src="form_6.png"/> jsou vrcholy trojúhelníka, <img class="formulaInl" alt="$ \overrightarrow{X(t)} $" src="form_7.png"/> je bod na hraně a parametr <img class="formulaInl" alt="$ t $" src="form_8.png"/> udává posun na úsečce.</p>
<div class="image">
<object type="image/svg+xml" data="clip.svg">clip.svg</object>
<div class="caption">
Ořez trojúhelníku pomocí ořezu hran. Při ořezu hran vzniknou nové body, ze kterých jsou následně sestaveny nové trojúhelníky.</div></div>
<p> Souřadnice bodu <img class="formulaInl" alt="$ \overrightarrow{X(t)} $" src="form_7.png"/> lze určit při vypočtení parametru <img class="formulaInl" alt="$ t $" src="form_8.png"/>, při kterém přestane platit nerovnice pro near rovinu <img class="formulaInl" alt="$ -X(t)_w \leq X(t)_z $" src="form_9.png"/>. Takové místo nastává v situaci <img class="formulaInl" alt="$ -X(t)_w = X(t)_z $" src="form_10.png"/>. Po dosazení z rovnice úsečky lze vztah přepsat na: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -X(t)_w &amp;=&amp; X(t)_z \\ 0 &amp;=&amp; X(t)_w + X(t)_z \\ 0 &amp;=&amp; A_w + t \cdot (B_w-A_w) + A_z + t \cdot (B_z - A_z) \\ 0 &amp;=&amp; A_w + A_z + t \cdot (B_w-A_w+B_z-A_z) \\ -A_w-A_z &amp;=&amp; t \cdot (B_w-A_w+B_z-A_z) \\ \frac{-A_w - A_z}{B_w-A_w+B_z-A_z} &amp;=&amp; t\\ \end{eqnarray*}" src="form_11.png"/>
</p>
<p>Pozice bodu <img class="formulaInl" alt="$ \overrightarrow{X(t)} $" src="form_7.png"/> a hodnoty dalších vertex atributů lze vypočítat lineární kombinací hodnot z vrcholů úsečky pomocí parametru <img class="formulaInl" alt="$ t $" src="form_8.png"/> následovně: <img class="formulaInl" alt="$ \overrightarrow{X(t)} = \overrightarrow{A} + t \cdot (\overrightarrow{B}-\overrightarrow{A}) $" src="form_4.png"/>.</p>
<h3><a class="anchor" id="PerspectiveDivision"></a>
Perspektivní dělení</h3>
<p>Perspektivní dělení následuje za clippingem a provádí převod z homogenních souřadnic na kartézské pomocí dělení w. </p><div class="image">
<object type="image/svg+xml" data="PerspectiveDivision.svg" width="500">PerspectiveDivision.svg</object>
<div class="caption">
Perspektivní dělení. Převod z clip-space do NDC (normalized device coordinates). Dělí se pomocí w. Při tomto dělení vzniknou normalizované souřadnice x,y a normalizovaná hloubka.</div></div>
<h3><a class="anchor" id="ViewPortTransformation"></a>
Viewport transformace</h3>
<p>Viewport transformace provádí převod NDC (rozsah -1, +1) na rozlišení okna, aby se mohla provést rasterizace. </p><div class="image">
<object type="image/svg+xml" data="ViewportTransformation.svg" width="500">ViewportTransformation.svg</object>
<div class="caption">
Vizualizace viewport transformace. Trojúhelníky jsou zoztaženy na rozlišení obrazovky [width,height].</div></div>
<h3><a class="anchor" id="Rasterization"></a>
Rasterizace</h3>
<p>Rasterizace rasterizuje trojúhelník ve screen-space. Rasterizace produkuje fragmenty v případě, že <b>střed</b> pixelu leží uvnitř trojúhelníka. Rasterizace by měla zapsat souřadnice fragmentu do proměnné <a class="el" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a> ve struktuře <a class="el" href="structInFragment.html">InFragment</a>. Pozice fragmentu obsahuje v x,y souřadnici na obrazovce a v z hloubku. <br />
 Další úkol rasterizace je interpolace vertex attributů do fragment attributů. Atributy (a jejich typ) které jsou posílány z vertex shaderu do fragment shaderu si uživatel může zvolit funkcí <a class="el" href="group__program__tasks.html#gaff499d4f692ea0dd7125bfd324957619">GPU::setVS2FSType</a>. Úkolem rasterizéru je perspektivně korektně interpolovat atributy. Perspektivně korektní interpolace využívá pro interpolaci barycentrické koordináty spočítané z 3D trojúhelníku a ne z 2D trojúhelníku. Interpolaci je možné provést i pomocí 2D barycentrických koordinát při použití perspektivní korekce:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\displaystyle \frac{\frac{A_0 \cdot \lambda_0}{h_0} + \frac{A_1 \cdot \lambda_1}{h_1} + \frac{A_2 \cdot \lambda_2}{h_2}}{\frac{\lambda_0}{h_0}+\frac{\lambda_1}{h_1}+\frac{\lambda_2}{h_2}}\]" src="form_12.png"/>
</p>
<p> Kde <img class="formulaInl" alt="$\lambda_0,\lambda_1,\lambda_2$" src="form_13.png"/> jsou barycentrické koordináty ve 2D, <img class="formulaInl" alt="$h_0,h_1,h_2$" src="form_14.png"/> je homogenní složka vrcholů a <img class="formulaInl" alt="$A_0,A_1,A_2$" src="form_15.png"/> je atribut vrcholu.</p>
<div class="image">
<object type="image/svg+xml" data="interpolation.svg">interpolation.svg</object>
<div class="caption">
Rasterizace a interpolace vertex atributů. Vertex Atributy jsou interpolovány pomocí perspektivně korektních barycentrických souřadnic w0,w1,w2. Fragmenty vznikají pouze tehdy, pokud jejich střed leží uvnitř trojúhelníku.</div></div>
 <h3><a class="anchor" id="FragmentProcessor"></a>
Fragment processor</h3>
<p>Fragment processor spouští fragment shader nad každým fragmentem. Data pro fragment shader jsou uložena ve struktuře <a class="el" href="structInFragment.html">InFragment</a>. Výstup fragment shaderu je výstupní fragment <a class="el" href="structOutFragment.html">OutFragment</a> - barva. Další (konstantní) vstup fragment shaderu jsou uniformní proměnné. </p><div class="image">
<object type="image/svg+xml" data="FragmentShader.svg" width="800">FragmentShader.svg</object>
<div class="caption">
Vizualizace vstupů a výstupů fragment shaderu. Fragment Shader se pouší nad každým vyrasterizovaným fragmentem.</div></div>
<h3><a class="anchor" id="PFO"></a>
Per-fragment operace</h3>
<p>Per-fragment operace provádí depth test. Ověření zda je nový fragment blíže než hloubka poznačená ve framebufferu. Pokud je hloubka nového fragment menší, barva a hloubka fragmentu je zapsána do framebufferu. Dejte pozor na přetečení rozsahu gl_FragColor. Před zápisem je nutné ořezat barvu do rozsahu &lt;0,1&gt;.</p>
<div class="image">
<object type="image/svg+xml" data="PFO.svg" width="800">PFO.svg</object>
<div class="caption">
Vizualizace depth testu. Starý fragment (jeho barva a hloubka) je nahrazen pokud nový fragment má menší hloubku.</div></div>
<h2><a class="anchor" id="PhongMethod"></a>
Implementace vykreslovací metody PhongMethod (úkol 2.)</h2>
<p>Druhý úkol je implementace vykreslování králička s phongovým osvětlovacím modelem a phognovým stínováním s procedurální texturou. Úkol je složen ze dvou částí: </p><ul>
<li>
<a class="el" href="group__shader__side.html">Implementace vertex a fragment shaderu</a> </li>
<li>
<a class="el" href="group__cpu__side.html">Implementace inicializace vykreslování a samotného kreslení</a> </li>
</ul>
<p>Pro implemenatci si můžete inspirovat příklady: <a class="el" href="triangleMethod_8cpp.html">triangleMethod.cpp</a> <a class="el" href="triangle3DMethod_8cpp.html">triangle3DMethod.cpp</a>, <a class="el" href="triangleBufferMethod_8cpp.html">triangleBufferMethod.cpp</a>, <a class="el" href="czFlagMethod_8cpp.html">czFlagMethod.cpp</a>.</p>
<div class="image">
<object type="image/svg+xml" data="examples.svg" width="1000">examples.svg</object>
<div class="caption">
příklady</div></div>
<p>V projektu jsou přítomny i nějaké další příklady. Tyto příklady můžete využít pro inspiraci a návod jak napsat vykreslování a shadery.</p>
<h2><a class="anchor" id="terminologie"></a>
Terminologie</h2>
<p><b>Vertex</b> je kolekce několika vertex atributů. Tyto atributy mají svůj typ a počet komponent. Každý vertex atribut má nějaký význam (pozice, hmotnost, texturovací koordináty), které mu přiřadí programátor/modelátor. Z několika vrcholů je složeno primitivum (trojúhelník, úsečka, ...)</p>
<p><b>Vertex atribut</b> je jedna vlastnost vrcholu (pozice, normála, texturovací koordináty, hmotnost, ...). Atribut je složen z 1,2,3 nebo 4 komponent daného typu (FLOAT, INT, ...). Sémantika atributu není pevně stanovena (atributy mají pouze pořadové číslo - attribIndex) a je na každém programátorovi/modelátorovi, jakou sémantiku atributu přidělí. </p><div class="image">
<object type="image/svg+xml" data="primitive.svg">primitive.svg</object>
<div class="caption">
Vertex attributes</div></div>
<p> <b>Fragment</b> je kolekce několika atributů (podobně jako Vertex). Tyto atributy mají svůj typ a počet komponent. Fragmenty jsou produkovány resterizací, kde jsou atributy fragmetů vypočítány z vertex atributů pomocí interpolace. Fragment si lze představit jako útržek původního primitiva.</p>
<p><b>Fragment atribut</b> je jedna vlastnost fragmentu (podobně jako vertex atribut).</p>
<p><b>Vertex Processor</b> (často označován za Vertex Shader) je funkční blok, který je vykonáván nad každým vertexem. Jeho vstup i výstup je Vertex. Výstupní vertex má obvykle jiné vertex atributy než vstupní vertex. Výstupní vertex má vždy atribut - gl_Position (pozice vertexu v clip-space). Vstupní vertex má vždy atribut - gl_VertexID (číslo vrcholu, s ohledem na indexování). Vertex Processor se obvykle stará o transformace vrcholů modelu (posuny, rotace, projekce). Jelikož Vertex Processor pracuje po vrcholech, je vhodný pro efekty jako vlnění na vodní hladině, displacement mapping apod. Vertex Processor má informace pouze o jednom vrcholu v daném čase (neví nic o sousednostech vrcholů). Vertex processor je programovatelný.</p>
<p><b>Fragment Processor</b> (často označován za Fragment Shader/Pixel Shader) je funkční blok, který je vykonáván nad každým fragmentem. Jeho vstup i výstup je Fragment. Výstupní fragment má obykle jiné attributy. Fragment processor je programovatelný.</p>
<p><b>Shader</b> je program/funkce, který běží na některé z programovatelných částí zobrazovacího řetezce. Shader má vstupy a výstupy, které se mění s každou jeho invokací. Shader má také vstupy, které zůstávají konstantní a nejsou závislé na číslu invokace shaderu. Shaderů je několik typů, v tomto projektu se používají pouze 2 - vertex shader a fragment shader. V tomto projektu jsou shadery reprezentovány pomocí standardních Cčkovských funkcí.</p>
<p><b>Vertex Shader</b> je program, který běží na vertex processoru. Jeho vstupní interface obsahuje: vertex, uniformní proměnné a další proměnné (číslo vrcholu gl_VertexID, ...). Jeho výstupní inteface je vertex, který vždy obsahuje proměnnou gl_Position - pozici vertexu v clip-space.</p>
<p><b>Fragment Shader</b> je program, který běží na fragment processoru. Jeho vstupní interface obsahuje: fragment, uniformní proměnné a proměnné (souřadnici fragmentu ve screen-space gl_FragCoord, ...). gl_FragCoord.xy - souřadnice ve screen space gl_FragCoord.z - hloubka Jeho výstupní interface je fragment. V projektu obsahuje atribut gl_FragColor - pro výstupní barvu.</p>
<p><b>Buffer</b> je lineární pole dat ve video paměti na <a class="el" href="classGPU.html" title="This class represent software GPU. ">GPU</a>. Do bufferů se ukládají vertex attributy vextexů modelů nebo indexy na vrcholy pro indexované vykreslování.</p>
<p><b>Uniformní proměnná</b> je proměná uložená v konstantní paměti <a class="el" href="classGPU.html" title="This class represent software GPU. ">GPU</a>. Všechny programovatelné bloky zobrazovacího řetězce z nich mohou pouze číst. Jejich hodnota zůstává stejná v průběhu kreslení (nemění se v závislosti na číslu vertexu nebo fragmentu). Jejich hodnodu lze změnit z CPU strany pomocí funkcí jako je uniform1f, uniform1i, uniform2f, uniformMatrix4fv apod. Uniformní proměnné jsou vhodné například pro uložení transformačních matic nebo uložení času.</p>
<p><b>Vertex Puller</b> se stará o přípravů vrcholů. K tomuto účelu má tabulku s nastavením. Vertex puller si můžete představit jako sadu čtecích hlav. Každá čtecí hlava se stará o přípravu jednoho vertex atributu. Mezi nastavení čtecí hlavy patří: ukazatel na začátek bufferu, offset a krok. Vertex puller může obsahovat indexování.</p>
<h1><a class="anchor" id="rozdeleni"></a>
Rozdělení</h1>
<p>Projekt je rozdělen do několika podsložek:</p>
<p><b>student/</b> Tato složka obsahuje soubory, které využijete při implementaci projektu. Složka obsahuje soubory, které budete odevzávat a podpůrné knihovny. Všechny soubory v této složce jsou napsány v jazyce C++ abyste se mohli podívat jak jednotlivé části fungují.</p>
<p><b>tests/</b> Tato složka obsahuje akceptační a performanční testy projektu. Akceptační testy jsou napsány s využitím knihovny catch. Testy jsou rozděleny do testovacích případů (TEST_CASE). Daný TEST_CASE testuje jednu podčást projektu.</p>
<p><b>doc/</b> Tato složka obsahuje doxygen dokumentaci projektu. Můžete ji přegenerovat pomocí příkazu doxygen spuštěného v root adresáři projektu.</p>
<p><b>images/</b> Tato složka obsahuje doprovodné obrázky pro dokumentaci v doxygenu. Z pohledu projektu je nezajímavá.</p>
<p>Složka student/ obsahuje soubory, které se vás přímo týkají:</p>
<p><a class="el" href="gpu_8hpp.html">gpu.hpp</a> a <a class="el" href="gpu_8cpp.html">gpu.cpp</a> obsahuje deklaraci a definici funkcí grafické karty - tady odvedete nejvíce práce.</p>
<p><a class="el" href="phongMethod_8hpp.html">phongMethod.hpp</a> a <a class="el" href="phongMethod_8cpp.html">phongMethod.cpp</a> obsahuje vykresleni králička - toto máte taky naprogramovat.</p>
<p><a class="el" href="fwd_8hpp.html">fwd.hpp</a> obsahuje definice typů a konstanty - projděte si.</p>
<p>Projekt je postaven nad filozofií OpenGL. Spousta funkcí má podobné jméno.</p>
<h1><a class="anchor" id="sestaveni"></a>
Sestavení</h1>
<p>Projekt byl testován na Ubuntu 18.04, Visual Studio 2017, 2019. Projekt vyžaduje 64 bitové sestavení. Projekt využívá build systém <a href="https://cmake.org/">CMAKE</a>. CMake je program, který na základně konfiguračních souborů "CMakeLists.txt" vytvoří "makefile" v daném vývojovém prostředí. Dokáže generovat makefile pro Linux, mingw, solution file pro Microsoft Visual Studio, a další. Postup:</p><ol type="1">
<li>stáhnout projekt</li>
<li>rozbalit projekt</li>
<li>ve složce build spusťte "cmake-gui .." případně "ccmake .."</li>
<li>vyberte si překladovou platformu (64 bit).</li>
<li>configure</li>
<li>generate</li>
<li>make nebo otevřete vygenerovnou Microsoft Visual Studio Solution soubor.</li>
</ol>
<h1><a class="anchor" id="spousteni"></a>
Spouštění</h1>
<p>Projekt je možné po úspěšném přeložení pustit přes aplikaci <b>izgProject</b>. Projekt akceptuje několik argumentů příkazové řádky, pro jejich výpis použijte parametr <b> -h </b></p><ul>
<li><b>-c ../tests/output.bmp</b> spustí akceptační testy, soubor odkazuje na obrázek s očekávaným výstupem.</li>
<li><b>-p</b> spustí performanční test.</li>
</ul>
<h1><a class="anchor" id="ovladani"></a>
Ovládání</h1>
<p>Program se ovládá pomocí myši a klávesnice:</p><ul>
<li>stisknuté levé tlačítko myši + pohyb myší - rotace kamery</li>
<li>stisknuté pravé tlačítko myši + pohyb myší - přiblížení kamery</li>
<li>"n" - přepne na další scénu/metodu "p" - přepne na předcházející scénu/metodu</li>
</ul>
<h1><a class="anchor" id="odevzdavani"></a>
Odevzdávání</h1>
<p>Před odevzdáváním si zkontrolujte, že váš projekt lze přeložit na merlinovi. Zkopirujte projekt na merlin a spusťte skript: <b>./merlinCompilationTest.sh</b>. Odevzdávejte pouze soubory <a class="el" href="gpu_8hpp.html" title="This file contains class that represents graphic card. ">gpu.hpp</a>, <a class="el" href="gpu_8cpp.html" title="This file contains implementation of gpu. ">gpu.cpp</a>, <a class="el" href="phongMethod_8hpp.html" title="This file contains phong rendering method. ">phongMethod.hpp</a> a <a class="el" href="phongMethod_8cpp.html" title="This file contains implementation of phong rendering method. ">phongMethod.cpp</a> Soubory zabalte do archivu proj.zip. Po rozbalení archivu se <b>NESMÍ</b> vytvořit žádná složka. Příkazy pro ověření na Linuxu: zip proj.zip <a class="el" href="gpu_8hpp.html" title="This file contains class that represents graphic card. ">gpu.hpp</a> <a class="el" href="gpu_8cpp.html" title="This file contains implementation of gpu. ">gpu.cpp</a> <a class="el" href="phongMethod_8cpp.html" title="This file contains implementation of phong rendering method. ">phongMethod.cpp</a> <a class="el" href="phongMethod_8hpp.html" title="This file contains phong rendering method. ">phongMethod.hpp</a>, unzip proj.zip. Studenti pracují na řešení projektu samostatně a každý odevzdá své vlastní řešení. Poraďte si, ale řešení vypracujte samostatně!</p>
<h1><a class="anchor" id="hodnoceni"></a>
Hodnocení</h1>
<p>Množství bodů, které dostanete, je odvozeno od množství splněných akceptačních testů a podle toho, zda vám to kreslí správně (s jistou tolerancí kvůli nepřesnosti floatové aritmetiky). Automatické opravování má k dispozici větší množství akceptačních testů (kdyby někoho napadlo je obejít). Pokud vám aplikace spadne v rámci testů, dostanete 0 bodů. Pokud aplikace nepůjde přeložit, dostanete 0 bodů.</p>
<h1><a class="anchor" id="soutez"></a>
Soutěž</h1>
<p>Pokud váš projekt obdrží plný počet bodů, bude zařazen do soutěže o nejrychlejší implementaci zobrazovacího řetězce. Můžete přeimplementovat cokoliv v odevzdávaných souborech pokud to projde akceptačními testy a kompilací.</p>
<h1><a class="anchor" id="zaver"></a>
Závěrem</h1>
<p>Ať se dílo daří a ať vás grafika alespoň trochu baví! V případě potřeby se nebojte zeptat (na fóru nebo napište přímo vedoucímu projektu <a href="#" onclick="location.href='mai'+'lto:'+'imi'+'le'+'t@f'+'it'+'.vu'+'tb'+'r.c'+'z'; return false;">imile<span style="display: none;">.nosp@m.</span>t@fi<span style="display: none;">.nosp@m.</span>t.vut<span style="display: none;">.nosp@m.</span>br.c<span style="display: none;">.nosp@m.</span>z</a>). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 23 2020 14:04:23 for Izg project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
